## 第一部分 数据系统的基石

### 第一章 可靠性 可扩展性 可维护性

1. **数据密集型**应用主要的挑战是是数据,**计算密集型**主要的挑战是cup处理速度.
2. 描述负载:负载可以用称为负载参数的若干数字来描述。参数的最佳选择取决于系统的体系结构，它可能是Web服务器的每秒请求处理次数，数据库中写入的比例 ,聊天室的同时活动用户数量， 缓存命中率等。 有时平均值很重要 ，有时系统瓶颈来自于少数峰值 .
3. 影响请求响应时间的因素:大多数请求是相当快的，但偶尔会有异常表示需要更长的时间 。 也许这些异常请求确实代价很高，例如它们的数据大很多。但有时，即使所有请求都相罔，也会由于其他变量因素而引入一些随机延迟抖动，这些因素包括上下文切换和进程调度、网络数据包丢失和TCP重传、垃圾回收暂停、缺页中断和磁盘I/O ，甚至服务器机架的机械振动.
4. 亚马逊还注意到，响应时间每增加100ms ，销售额就会下降了约 1 % ，其他研究则表明， 1s的延迟增加等价于客户满意度下降 16%。  

### 第二章 数据模型与查询语言

1. 关系数据库和文档数据库:文档数据库更像json一样将对象的所有的信息展示出来,应用处理更加的方便.但关系型数据库更适合存储有**级联操作**的数据.
2. 数据更改时,文档数据只需要用新的字段编写并处理之前旧的字段,而关系型数据库则需要用alert语句,更改数据 的字段.关系数据这种操作很费事.
3. 命令式查询语言和声明式查询语言.
4. 各种不同的数据模型.

### 第三章 数据存储与检索

1. 索引:它们背后的基本原理都是保留一些额外的元数据，这些元数据作为路标，帮助定位想要的数据。
2. Hash索引：索引里面记录了value每一行的地址，检索的时候可以快速定位。
   1. 劣势:需要将所有的索引放入到内存中,且范围查询不友好.
3. SSTable:每个日志结构的存储段都是一组k巳 y-value对的序列。这些 key-valu 巳对按
   照它们的写入 111员序排列，并且对于出现在 日志中的同一个键，后出现的值优于之前的值。除此之外，文钊二 中 key-value对的顺序并不重要。这种格式称为**排序字符串表**，或简称为SSTable    
   1. SSTable的压缩方式：在**大小分级**的压缩中，较新的和较小的SSTa bl es被连续合并到较旧和较大的SSTa bl es。在**分层压缩**中，键的范围分裂成多个更小的SSTa ble s ，旧数据被移动到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间。  
4. B-trees:
5. 事务处理与分析处理

## 第二部分 分布式数据结构

### 第五章 数据复制

1. 共享内存架构和共享磁盘架构:内存架构的可扩展性不强,它仍局限于某个特定的地理位置，无主主提供异地容错能力。  
2. 无共享架构:运行数据软件的机器或者虚拟机被称为节点,每个节点独立使用本地cup,内存和磁盘,通信通过网络来实现,是广泛应用的模式.
3. 数据复制:多台机器复制相同的数据,一个副部失效其它可以接替使服务继续运行.主从复制,多主节点复制和无主节点复制.
4. 创建新的节点:从节点会复制主节点的数据,在复制的时候,主节点会记录在此期间影响数据一致性的日志,待从节点复制完成,同步日志.
5. 从节点失效:当从节点能顺利重启,例如遇到暂时的网络中断,从节点会磁盘会记录事务日志,恢复到崩溃之前的最后一条日志.
6. 分布式系统核心的基本问题:节点失效、网络不可靠、副本一致性、持久性、可用性与延迟之间各种细微的权衡，实际上正是分布式系统核心的基本问题。
7. 复制日志的实现:
   1. 基于语句的复制:将增删改的日志进行记录,同步从节点.
   2. 预写日志:同步的是磁盘引擎的数据结果.
   3. 行逻辑日志:记录行级别的日志.
   4. 基于触发器:不是由数据库实现的而是通过软件实现,应对只需要复制部分数据的需求.
8. 复制滞后问题
   1. 读写一致性:
      - 即读取的数据优先从自己写的地方读取.优先从主节点读取数据.此种情况适用于例如用户编辑自己的材料,而多人多可编辑的东西就不适合,是系统丧失了可扩展性.主节点可是设置一个时间戳,等待所有从节点都同步后才允许提供读的服务.
      - 如果读取的信息不再同一个设备例如web端和移动端,必须要保证他们的数据中心是一致的.
   2. 单调读:确保用户读取的数据从同一个从节点进行读取,避免了因为数据不同步导致之前读到的信息在第二次请求的时候消失了.
   3. 前缀一致读:保证消息的顺序.
   4. 多主节点适用的场景:多数据中心,离线客户端操作,协作编辑.
   5. 多主节点处理写冲突:指定特定的主节点进行写操作.
      1. 收敛一致状态一般的解决方法是写操作设置时间戳,或者给从节点设置编号编号大的优先执行,但是都会有丢失数据的风险.
      2. 自定义冲突解决逻辑:在应用层解决,写入读取日志的时候监测冲突并处理.读取时候将所有节点的值都读到比较处理冲突.
   6. 无主节点复制:客户端读取数据的时候,可能会读取失效的数据,需要根据版本号进行排查,保证数据的一致性.

### 第六章 数据分区

1. 面对一些海量数据或非常高的查询压力,复制技术还不够,我们需要将数据拆分成分区,也称为分片.
2. 键-值数据的分区:
   1. 想让数据尽可能均匀的分配到多个节点上,提高读写吞吐量.
   2. 基于关键字区间分区:
      - 难点 数据本来就不均匀.
      - 直接用时间戳进行排序,会导致写入数据的时候,都集中在一个节点,一般会以设备名称作为前缀.
   3. 基于关键字哈希值分区
      - 根据hash范围进行分区,但要丧失区间查询特性.
      - 做一个折中的方案,可以声明由多个列组成的复合主键,复合主键只有第一部分可以用于hash分区,其它的部分用作组合索引对表中的数据进行排序.
   4. 负载倾斜与热点
      - 如果消息都是相同的关键字,即使用了hash算法,还是会导致数据集中在一个节点上.
      - 解决办法是在这类特殊的关键字上加上一个随机数.
   5. 分区与二级索引
      1. 二级索引带来的主要挑战是它们不能规整的地映射到分区中。有两种主要的方法来支持对二级索引进行分区：基于文档的分区和基于词条的分区。 
      2. 基于文档的分区:每个分区完全独立，各自维护自己的二级索引，且只负责自己分区内的文档而不关心其他分区中数据。缺点是想要建立的二级索引可能不会在同一个分区上,需要用户自己构建合理的分区方案.
      3. 基于词条的二级分区:对所有的数据构建全局索引.但是索引必须分区.但是创建的时候非常的复杂.所有的数据库都不支持**更新**二级索引.
   6. 分区在平衡
      1. 查询压力增加,数据规模增加,节点出现故障都需要分区在平衡.
      2. 固定数量的分区:创建远超实际节点数的分区数，然后为每个节点分配多个分区。如果添加新的节点,就从冗余的分区数中匀一个,这样并不会改变关键字到分区的映射关系.
   7. 动态分区
      1. 根据数据动态的进行分区或者进行分区的合并.如果没有达到分区条件,导致总是一个分区进行服务,可以通过预分裂进行优化.
   8. 请求路由
      1. 当客户端获取数据的时候,多个节点会进行跳转,最终找到数据.一般会使用zookeeper,处理协同类的信息.节点发生的变化,也会第一时间同步到zookeeper中.

### 第七章 事务

1. 事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。要么都成功,要么多失败.
2.   多对象事务的必要性:因为会出现跨分区操作,多对象事务实现非常困难.除了分区,当设计系统多部分的更改属性的时候还是需要保证多对象的事物.例如:关系数据模型,有些值的更改对其它数据有影响,不能只执行部分的操作.
3. 重试中止的事物虽然是简单有效的错误处理机制,但它并不完美:
   1. 如果数据操作部分已经成功,只是返回客户端的时候进行了错误的提示,这回导致操作的重复.
   2. 如果错误由系统超负荷导致,重试只会加剧错误.
   3. 出现了永久性故障,重试毫无意义.
   4. 如果事务有其它副作用,例如发送一封邮件,会带来不好的体验.
4. 写倾斜和数据丢失如果两个事务读取相同的一组对象，然后更新其中 一部分:不同的事务可能更新不同的对象，则可能发生写倾斜 ;而不同的事务如果更新的是同一个对象，则可能发生脏写或更新丢失 .
5. 串行化:严格按照串行顺序执行(实际串行执行),两阶段锁和乐观并发控制技术.
6. 实际串行执行:即在一个线程上按顺序方式每次只执行一个事务 .
   1. Redis就采用了这种方式.避免了锁开销和内存切换.
   2. 不支持交互式的多语句事务(即下一个数据处理需要等待上一次处理的结果).将所有的数据加载到内存中.
   3. 写入吞吐量必须足够低,才能在单个cpu核上处理,否则采用分区技术,最好没有跨区的事物.
   4. 跨区事物也可以支持,但占比需要非常的小.
7. 两阶段加锁:只有这一种串行化算法被数据库广泛使用.第一阶段事务执行需要获取锁,第二阶段事务执行结束则释放锁.两阶段加锁名称的由来.
8. 基本用法:
   - 事务想要读取对象,必须先以共享的模式获得锁.可以有多个事务同时获得一个对象的共享锁.
   - 如果事务想要修改对象必须以独占模式获取锁.如果该对象已经被加锁,则修改的事务必须等待.
   - 如果事务首先读取对象,然后尝试写入对象,必须将共享锁升级为独占锁.
9. 谓词锁:作用类似于共享或者独占锁,区别在于它并不属于某个特定的对象,而是作用于满足某些搜索条件的所有查询对象.
10. 索引区间锁:由于谓词锁性能不佳,光检查锁就很耗费资源,索引我们大部分情况下使用的是索引区间锁.索引区间锁对谓词锁做了粗话,使它的性能得到了提升.



