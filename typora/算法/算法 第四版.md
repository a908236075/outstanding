# 算法 第四版

## 第一章 算法简介

1. 时间复杂度
   - 一个程序或者算法的时间效率.
   - 复杂度通常用O(n)表示,**n代表问题的规模.**
   - 算法运行过程中,某种时间固定的操作需要被执行的**次数和n的关系**来度量的.
   - 只统计次数最多的那种固定操作的次数例如O( n^2)+O(n),只用O(n的平方)表示.
   - 平均复杂度和最坏复杂度.
   - 算法的时间复杂度,复杂度依次变多.
     - ![](..\picture\算法\算法的时间复杂度.png)
     
     - ![](..\picture\算法\随着问题规模上升的时间曲线.png)
   
2. 二分法

   - ~~~java
     public static int findNumber(int key, int[] a) {
             int start = 0;
             int end = a.length - 1;
             int time=0;
             //为什么是start<=end
             // 第二次查找 mid=3+(4-3)/2=3
             // 导致start=4并且end=4
             while (start <=end) {
                 time++;
                 int mid = start+(end-start)/2;
                 if ((key < a[mid])) {
                     end = mid-1;// 为什么是mid-1 a[mid]已经不是了,减少一个数
                 } else if (key > a[mid]) {
                     start = mid+1;// 为什么是mid+1
                 } else {
                     System.out.println("time total is "+time);
                     return mid;
                 }
             }
             return -1;
         }
     ~~~

3. 对象本身的开销一般是16字节.包含指向对象类型的引用,垃圾收集信息以及同步信息.

4. stack 用链表和数组实现栈的操作.

   1. 链表:需要处理各个节点的连接,所有需要更多的时间,优点是性能消耗上更平均或者说是不变,不会突然的性能下降.
   2. 数组:插入和存取数据数据为常数项,总体而言花费的时间和空间更少,但是创建数组需要确定容量,容量扩容需要将原来的数组的数据进行拷贝,每次访问需要判断数组的容量的大小.一般扩容为2倍,当数据小于1/4时,进行缩容为原来的1/2.
   
5. 用栈做计算

   1. 维护了两个栈,一个是数值栈,另一个是操作符栈.
   2. 当遇到左符号的时候,忽略掉,用到右符号的时候,计算最近的栈的数字.如图遇到右括号计算3+2.
   3. ![](..\picture\算法\栈计算表达式.png)

## 第二 排序

1. 选择排序的定义:

   1. 找到数组中最小的元素,比较他和数组的第一个元素交换位置.
   2. 剩余的元素中找到最小的元素,将它与数组的第二个元素进行交换.直到排好序.
   3. 分析 **交换**的总次数是N,算法时间效率取决于比较的次数.
   4. 比较的次数为:(N-1)+(N-2)+(N-3)+...+1~1/2*N^2
   
2. 选择排序代码实现

   1. ~~~java
      private static void selectionSort(Comparable[] a) {
              for (int i = 0; i < a.length-1; i++) {
                  Comparable min = a[i];
                  for (int j = i+1; j <a.length ; j++) {
                      if (min.compareTo(a[j]) > 0) {
                          exchange(a,i,j);
                      }
                  }
              }
          }
      ~~~

3. 插入排序

   1. 像整理扑克时候一样,将每一张插入到其它已经有序的牌中的适当位置.
   2. 与选择排序不同,插入排序所需要的时间取决于输入中元素的初始顺序.
   3. 平均的情况下,插入排序需要1/4N^2比较和1/4N^2交换,最坏的情况下为1/2N^2的比较以及交换.
   4. 最坏的情况下是对角线一下的元素都需要进行比较以及移动,即1/2N^2,而平均对角线一半的元素进行比较和移动即1/4N^2.

4. 希尔排序 ---**插入排序的升级版**

   1. 如果最小的元素,恰好在数组的尽头,则需要一步步移动N-1次.希尔排序是使移动变成h,将i到i+h进行局部排序,最后在将移动的步骤为1,进行排序.

   2. ~~~java
      private static void shellSort(Comparable[] nums) {
              int N = nums.length;
              int h = 1;
              while (h < N / 3) {
                  h = h * 3 + 1;
              }
              while (h >= 1) {
                  for (int i = h; i < N; i++) {
                      // 将a[i] 插入到a[i-h],a[i-2*h],a[i-3*h]....
                      for (int j = i; j >= h && less(nums, j, j - h); j -= h) {
                          exchange(nums, j, j - h);
                      }
                  }
                  h = h / 3;
              }
          }
      ~~~

   3. h影响了希尔排序的效率,但h不能通过实验得出确切的值,只能知道不插入排序的效率高.

5. 插入排序算法的实现

   1. ~~~java
      /**
           * 插入排序
           *
           * @param a
           */
      private static void insertSort(Comparable[] a) {
          for (int i = 1; i < a.length; i++) {
              // 将a[i] 插入到a[i-1],a[i-2],a[i-3]...中.
              for (int j = i; j > 0 && less(a, j, j - 1); j--) {
                  exchange(a, j, j - 1);
              }
          }
      }
      ~~~

   2. 

6. 归并排序

   1. ~~~java
       public void sort4(Comparable[] a,int lo,int mid,int hi){
              Comparable[] au = new Comparable[0];
              for (int k = 0; k < a.length; k++) {
                  au[k]=a[k];
              }
              int i=lo;
              int j=mid+i;
           // 左边取尽 直接取右边
              if (i>mid){
                  a[i]=au[j++];
              }else if(j>hi){
                  a[i] = au[i++];
              } else if (less(a[j], a[i])) {
                  // 排序,小的放在左边
                  a[i] = au[j++];
              } else {
                  a[i]=au[i++];
         
              }
          }
      ~~~

7. 归并排序比较次数的上界和下界.????

8. 自顶向下归并排序树形图,一共有n层树结构,每k层有2^k个数组,每个数组的剩余元素为2^(n-k)个,需要比较2^(n-k)次,所以需要比较的次数为n*2^n,即NLgN.

9. 快速排序法是一种分治的排序算法,将数组分成了两个数组,将两部分独立的排序.归并排序是将数组分成两个数组分别排序,并将有序的子数组归并实现整个数组的排序.而快速排序是当两个数组都有序时,整个数组也就有序了.归并排序递归调用发生在处理整个数组之前;快速排序递归调用发生在处理整个数组之后.归并排序将数组一分两半,快速排序取决于数组的内容.

10. 快速排序的切分逻辑:选择一个标的例如a[0]=k,进行扫描,从左边扫描,知道遇见大于k的值停止,同时从右边扫描,直到遇见小于k的值停止,交换i,j的值,继续扫描.最后将a[i]值与a[0]进行交换,这样k左边的值小于k,k右边的值大于k.

11. 快速排序的内循环中移动数据和比较次数都比较小.

12. ~~~java
    // 快速排序的代码实现
    public static Comparable fastSort(Comparable[] a,int lo,int hi) {
            Comparable index = a[0];
            int i=lo;
            int j=hi+1;
            while (true) {
                while (a[++i].compareTo(index)<0) if (i==hi) break;
                while (a[--j].compareTo(index)>0) if (j==lo) break;
                if (j<=i) break;
                // 左边的值大于标的,右边的值小于标的 交换i,j
                exchange(a,i,j);
            }
        // 最后在将标的与j交换,交换后左边的值都小于标的,右边的值都大于标的.
            exchange(a,lo,j);
            return j;
        }
    
    
    // 三向切分的快速排序  
    // 可以有效的处理数组中有很多相同的值.
    // v 首先与i比较,i值小于v的值做交换,v的索引变成新索引值即lt++,但是因为在循环外,比较的v值并没有变.
    // 如果i值大于v的值,择将它与gt值做交换.仅仅做交换,将大的值移动到数组后面而已.
    // 循环下去,继续比价v与i的值.
    // 最后根据新的lt进行递归.
    private static void  quickSort3Way(Comparable[] a, int lo, int hi) {
            if (hi <= lo) return;
            int lt = lo, i = lo + 1, gt = hi;
            Comparable v = a[lo];
            while (i <= gt) {
                int cmp = a[i].compareTo(v);
                if (cmp < 0) {
                    exchange(a, lt++, i++);
                } else if (cmp > 0) {
                    // 注意 没有i++
                    exchange(a, i, gt--);
                } else i++;
            }
            quickSort3Way(a, lo, lt - 1);
            quickSort3Way(a, gt + 1, hi);
        }
    ~~~

13. 当一棵二叉树的每个结点都大于等于它的两个子节点时,它被称为**堆有序**.

14. 对于含有N个元素的基于堆的优先队列,插入元素操作只需要不超过(lgN+1)次比较,删除最大元素的操作需要不超过2lgN次比较.

15. 红黑二叉查找树:红链接将两个2-节点连接起来构成一个3-节点,黑链接则是2-3树的普通链接.另一种定义:红链接均为左连接,没有任何节点同时和2条红链接相连,该树是完美的红黑树和相应的2-3树相对应.

16. 一棵树的**大小**是它的节点数量.树中的一个节点的**深度**是它到根节点的距离.**树的高度**是它所有节点中**最大**的深度**.**

17. **排序成本模型:**在研究排序算法时,我们需要计算**比较和交换**的数量.对于不交换元素的算法,我们会计算**访问数组**的其它排序算法.

18. **平衡二叉树**是指任意的空节点到根节点的距离都相等.

19. 红黑二叉查找树:红链接将两个2-节点连接起来构成一个3-节点,黑链接则是2-3树的普通链接.另一种定义:红链接均为左连接,没有任何节点同时和2条红链接相连,该树是完美的红黑树和相应的2-3树相对应.
