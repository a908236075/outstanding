# 图解算法

## 第一章 算法简介

1. 时间复杂度
   - 一个程序或者算法的时间效率.
   - 复杂度通常用O(n)表示,**n代表问题的规模.**
   - 算法运行过程中,某种时间固定的操作需要被执行的**次数和n的关系**来度量的.
   - 只统计次数最多的那种固定操作的次数例如O( n^2)+O(n),只用O(n的平方)表示.
   - 平均复杂度和最坏复杂度.
   - 算法的时间复杂度,复杂度依次变多.
     - ![](..\picture\算法\算法的时间复杂度.png)
     
     - ![](..\picture\算法\随着问题规模上升的时间曲线.png)
   
2. 二分法

   - ~~~java
     public static int findNumber(int key, int[] a) {
             int start = 0;
             int end = a.length - 1;
             int time=0;
             //为什么是start<=end
             // 第二次查找 mid=3+(4-3)/2=3
             // 导致start=4并且end=4
             while (start <=end) {
                 time++;
                 int mid = start+(end-start)/2;
                 if ((key < a[mid])) {
                     end = mid-1;// 为什么是mid-1 a[mid]已经不是了,减少一个数
                 } else if (key > a[mid]) {
                     start = mid+1;// 为什么是mid+1
                 } else {
                     System.out.println("time total is "+time);
                     return mid;
                 }
             }
             return -1;
         }
     ~~~

3. 对象本身的开销一般是16字节.包含指向对象类型的引用,垃圾收集信息以及同步信息.

## 第二章 排序

1. 选择排序的定义:

   1. 找到数组中最小的元素,比较他和数组的第一个元素交换位置.
   2. 剩余的元素中找到最小的元素,将它与数组的第二个元素进行交换.直到排好序.
   3. 分析 **交换**的总次数是N,算法时间效率取决于比较的次数.
   4. 比较的次数为:(N-1)+(N-2)+(N-3)+...+1~1/2*N^2
   
2. 选择排序代码实现

   1. ~~~java
      private static void selectionSort(Comparable[] a) {
              for (int i = 0; i < a.length-1; i++) {
                  Comparable min = a[i];
                  for (int j = i+1; j <a.length ; j++) {
                      if (min.compareTo(a[j]) > 0) {
                          exchange(a,i,j);
                      }
                  }
              }
          }
      ~~~

3. 插入排序

   1. 像整理扑克时候一样,将每一张插入到其它已经有序的牌中的适当位置.
   2. 与选择排序不同,插入排序所需要的时间取决于输入中元素的初始顺序.
   3. 平均的情况下,插入排序需要1/4N^2比较和1/4N^2交换,最坏的情况下为1/2N^2的比较以及交换.
   4. 最坏的情况下是对角线一下的元素都需要进行比较以及移动,即1/2N^2,而平均对角线一半的元素进行比较和移动即1/4N^2.

4. 插入排序算法的实现

   1. ~~~java
      /**
           * 插入排序
           *
           * @param a
           */
      private static void insertSort(Comparable[] a) {
          for (int i = 1; i < a.length; i++) {
              // 将a[i] 插入到a[i-1],a[i-2],a[i-3]...中.
              for (int j = i; j > 0 && less(a, j, j - 1); j--) {
                  exchange(a, j, j - 1);
              }
          }
      }
      ~~~

   2. 

5. 归并排序

   1. ~~~java
       public void sort4(Comparable[] a,int lo,int mid,int hi){
              Comparable[] au = new Comparable[0];
              for (int k = 0; k < a.length; k++) {
                  au[k]=a[k];
              }
              int i=lo;
              int j=mid+i;
           // 左边取尽 直接取右边
              if (i>mid){
                  a[i]=au[j++];
              }else if(j>hi){
                  a[i] = au[i++];
              } else if (less(a[j], a[i])) {
                  // 排序,小的放在左边
                  a[i] = au[j++];
              } else {
                  a[i]=au[i++];
         
              }
          }
      ~~~

6. 

7. 一棵树的**大小**是它的节点数量.树中的一个节点的**深度**是它到根节点的距离.**树的高度**是它所有节点中**最大**的深度**.**

8. **排序成本模型:**在研究排序算法时,我们需要计算**比较和交换**的数量.对于不交换元素的算法,我们会计算**访问数组**的其它排序算法.

9. 自顶向下归并排序树形图,一共有n层树结构,每k层有2^k个数组,每个数组的剩余元素为2^(n-k)个,需要比较2^(n-k)次,所以需要比较的次数为n*2^n,即NLgN.

10. **平衡二叉树**是指任意的空节点到根节点的距离都相等.

11. 红黑二叉查找树:红链接将两个2-节点连接起来构成一个3-节点,黑链接则是2-3树的普通链接.另一种定义:红链接均为左连接,没有任何节点同时和2条红链接相连,该树是完美的红黑树和相应的2-3树相对应.
