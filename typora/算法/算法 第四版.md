# 图解算法

## 第一章 算法简介

1. 时间复杂度
   - 一个程序或者算法的时间效率.
   - 复杂度通常用O(n)表示,**n代表问题的规模.**
   - 算法运行过程中,某种时间固定的操作需要被执行的**次数和n的关系**来度量的.
   - 只统计次数最多的那种固定操作的次数例如O( n^2)+O(n),只用O(n的平方)表示.
   - 平均复杂度和最坏复杂度.
   - 算法的时间复杂度,复杂度依次变多.
     - ![](..\picture\算法\算法的时间复杂度.png)
     
     - ![](..\picture\算法\随着问题规模上升的时间曲线.png)
   
2. 二分法

   - ~~~java
     public static int findNumber(int key, int[] a) {
             int start = 0;
             int end = a.length - 1;
             int time=0;
             //为什么是start<=end
             // 第二次查找 mid=3+(4-3)/2=3
             // 导致start=4并且end=4
             while (start <=end) {
                 time++;
                 int mid = start+(end-start)/2;
                 if ((key < a[mid])) {
                     end = mid-1;// 为什么是mid-1 a[mid]已经不是了,减少一个数
                 } else if (key > a[mid]) {
                     start = mid+1;// 为什么是mid+1
                 } else {
                     System.out.println("time total is "+time);
                     return mid;
                 }
             }
             return -1;
         }
     ~~~

3. 对象本身的开销一般是16字节.包含指向对象类型的引用,垃圾收集信息以及同步信息.

## 第二章 排序

1. 归并排序

   1. ~~~java
       public void sort4(Comparable[] a,int lo,int mid,int hi){
              Comparable[] au = new Comparable[0];
              for (int k = 0; k < a.length; k++) {
                  au[k]=a[k];
              }
              int i=lo;
              int j=mid+i;
           // 左边取尽 直接取右边
              if (i>mid){
                  a[i]=au[j++];
              }else if(j>hi){
                  a[i] = au[i++];
              } else if (less(a[j], a[i])) {
                  // 排序,小的放在左边
                  a[i] = au[j++];
              } else {
                  a[i]=au[i++];
         
              }
          }
      ~~~

2. 自顶向下归并排序树形图,一共有n层树结构,每k层有2^k个数组,每个数组的剩余元素为2^(n-k)个,需要比较2^(n-k)次,所以需要比较的次数为n*2^n,即NLgN.

3. **平衡二叉树**是指任意的空节点到根节点的距离都相等.

4. 红黑二叉查找树:红链接将两个2-节点连接起来构成一个3-节点,黑链接则是2-3树的普通链接.另一种定义:红链接均为左连接,没有任何节点同时和2条红链接相连,该树是完美的红黑树和相应的2-3树相对应.
