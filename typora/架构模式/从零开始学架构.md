# 第一部分 概念和基础

## 基础架构

### 模块和组件的区别:

​	从逻辑的角度查分得来的单元是"模块",从物理角度拆分的系统得到的单元是"组件";划分模块的主要目的是职责分离,划分组件的主要目的是单元复用.

### 为什么要做架构设计

1. 架构设计是为了解决**复杂度**带来的问题.顺带解决了系统的高性能,高可用和可扩展.
2. 高性能
   1. 单机:手动输入命令-->批处理-->进程(CPU分成很多段,每个任务有独立的进程空间)--> 线程(为了让进程并行处理任务)
   2. 集群:

## 架构设计原则

### 合适原则

​	优秀的架构是业务量倒逼出来的,没有真实的场景永远是纸上谈兵.所以想提高,也点到真实的场景中去.

### 简单原则

​	Keep It Simple Stupid!

### 演化原则

​	演化优于一步到位.对于建筑来说,永恒是主题,对于软件来说,变化才是主题.

## 架构设计流程

### 识别系统复杂度

​	高性能,高可用和高扩展三方面,最多设计两方面的优化.

### 设计备选方案

1. 架构设计最常见的错误
   - 设计最优秀的方案.
   - 只做一个方案.正确的备选方案数量为3~5个.备选方案需要具有差异化.不能只局限于已经熟悉的技术.
   - 备选方案过于详细.

### 评估和选择备选方案

1. 最简派,最牛派,最熟派,领导派.
2. 常见错误:
   - 数量对比法 集群方案2个占优比拆分方案3个占优少,所以选择拆分方案.质量属性的重要性不等同.
   - 加权法:每个属性给一个权值,但是权值并不客观,放在不同的公司权值并不相同.
3. 正确的做法是:按优先级选择.例如创业公司可能成本最优先.
4. 避免方案重选
   1. 必须要深入理解选择方案的组件,例如ElastichSearch,熟悉它的细节.
   2. 降低方案复杂度,越复杂的方案越容易被细节推翻.
   3. 如果方案本身就很复杂,就让大家一起讨论.
5. 为什么任务分解就能提升性能呢
   1. 简单的系统更加容易做到高性能.
   2. 可以针对单个的任务进行扩展.
6. 高性能:系统无中断的执行其功能.
   1. 本质上通过"**冗余**"来解决高可用.
   2. 计算高可用和存储高可用.存储高可用的难点不在于如何备份数据,而在于如何减少或规避数据不一致对业务造成的影响.
7. 安全性在架构设计中很少体现,一般依靠运营商和云服务商.

## 存储高性能

### 读写分离

为了避免数据延时,可以将关键业务到主库读取,非关键业务到从库读取.

### 分库分表

1. 根据业务分库引发的问题:
   1. join操作不能直接查询
   2. 事务问题
   3. 成本问题

2. 怎样解决
   1. 单台数据库能够支撑10万用户量级的业务,对于创业团队,先可以不分库.

3. 分表
   1. 垂直分表:相较于水平更加的简单.
   2. 水平分表:单表行数超过5000万需要进行分表,仅仅最为参考,需要看业务数据具体的特性.
   3. 水平分表如何操作
      1. 范围路由:根据ID范围进行分表,分的太大,会使数据不均匀,分的太小会使维护变得困难.
      2. Hash路由:优先分布的比较均匀,缺点是扩充新的表很麻烦.
      3. 配合路由:新增一张中间表,将id映射关系保存在表中.缺点是每次查询都要多查询一次.

   4. 水平分表后的影响
      1. join操作:需要在业务代码或者数据库中间件中进行多次join查询,然后将结果合并.
      2. count操作
         1. 多报表查询然后count相加,如果串行很多表需要几秒钟才能获取到结果.
         2. 记录数表:新建一张表,专门记录数据总数,但会设计到数据添加异常导致不同步的问题.也增加了数据的读写压力.

      3. order by:能有通过业务代码进行汇总后排序.

4. 分库分表实现方法
   1. 程序代码封装:实现简单,每个变成夜宴都需要自己实现一次,无法通用.故障情况下如果主从切换发生,可能需要所有系统修改配置并重启.
   2. 中间件封装:主流的方式可以选择的是mysql-proxy,mysql-router,360的Atlas

### NoSQL

1. 相比于NoSql,关系型数据库有如下缺点:
   1. 无法存储数据结构.
   2. 表结构扩展很不方便,修改时间可能会长时间的锁表.
   3. 关系型数据库在大数据场景下I/O较高.
   4. 全文检索功能比较弱,即like.
2. NoSQL的类型
   1. K-V存储类型:解决关系型数据库无法存储数据结构的问题,Redis为代表.
   2. 文档数据库:~强Schema(表结构)约束的问题,MongoDB为代表.
   3. 列式数据库:~大数据场景下的I/O问题,以HBase为代表
   4. 全文搜索引擎:以ElastichSearch为代表.
3. K-V存储
   1. key都是String,Value包括:string,hash,list,set,sorted set,bitmap和hyperloglog.
   2. Redis的事务只能保证隔离性和一致性(I和C),无法保证原则性和持久性(A和D).
   3. Redis的ACID
      1. 原子性:不支持事务的回滚.随意不支持原子性.
      2. 一致性:保证事物开始之前和事务结束之后,数据库完整性没有被破坏.
      3. 隔离性:单线程,不存在多个事务的问题.
      4. 持久性:持久化方式:RDB和AOF.
   4. RDB与AOF
      1. RDB持久化只备份当前内存中的数据集，事务执行完毕时，其数据还在内存中，并未立即写入到磁盘，所以RDB持久化不能保证Redis事务的持久性。
      2. AOF持久化是先执行命令，执行成功后再将命令追加到日志文件中。即使AOF每次执行命令后立刻将日志文件刷盘，也可能丢失1条命令数据，因此AOF不能严格保证Redis事务的持久性。
4. 文档数据库
   1. 解决关系型数据库schema带来的问题.可以存储和读取任意类型的数据,存储最多的json.
   2. 但是不支持事务.无法实现join操作.
5. 列式数据库
   1. 传统关系型数据库被称为"行式数据库".在特性的业务场景下优势才能体现.
   2. 列式数据库,能够一次处理多列,例如查询超重人数,行式数据库即使只使用一列,也需要将所有行数据读取出来.
   3. 但是更新列的时候,由于列的空间不连续,则变成了随机的IO.
6. 全文搜索引擎.
   1. 倒排索引.

### 缓存

1. 需要用到缓存的场景
   1. 需要经过复杂运算后得出的数据,存储系统无能为力.
   2. 都多写少的数据.
2. Memcache,单台服务器简单的key-value查询能够达到5万以上的TPS.
3. 缓存穿透
   1. 存储数据不存在
      1. 当查询存储系统的数据没有找到,则直接设置一个默认值(可以是空值,也可以是一个具体的值)并存在缓存中.二次读取的时候获取的就是默认值,而不是访问存储系统.
   2. 缓存数据生成耗费大量时间或资源.
      1. 如果竞争对手用爬虫来遍历的时候,从第一页到最后一页都生成缓存数据.因为10页之后的数据可能没有缓存,导致大量的缓存需要生成.
      2. 解决办法是识别爬虫.
4. 缓存雪崩
   1. 当缓存失效后引起的性能急剧下降的情况.
   2. 解决方法:
      1. 更新锁:对缓存更新操作进行加锁保护.保证只有一个线程能够进行缓存更新.分布式系统要引入分布式锁如ZooKeeper.
      2. 后台更新:
         1. 后台线程更新而不是用业务线程进行更新缓存,但是当内存不够会踢掉一些缓存数据,为了避免被踢掉缓存读不到返回空值,有两种方法.
         2. 定时读取
            1. 后台线程除了定时更新缓存,还要频繁的读取缓存,间隔时间设置为1秒或者100毫秒.
            2. 消息队列通知
5. 缓存热点
   1. 虽然缓存系统本身的性能比较高,但对于热点数据,需要复制多分缓存.

## 计算高性能

### 单服务器高性能

1. 关键之一就是服务器采用的网络编程模型

2. PPC Process per Connection 的缩写
   1. 每次有新的连接就新建一个**进程**去专门处理这个连接的请求,传统UNIX网络服务所采用的模型.
   2. ![](..\picture\架构\PPC.png)
   3. 缺点:
      1. fork代价高,需要分配很多内核资源,需要将内存映像复制到子进程.
      2. 父子进行通信复杂.
      3. 大量的进程调度和切换对操作系统压力很大.

3. prefork:解决PPC模式fork代价大的问题.提前创建好进程.
   1. ![](..\picture\架构\prefork.png)
   2. 父子进程通信复杂,支持并发连接数有限的问题没有解决.

4. TPC:Thread per Connection 每次有新的连接就创建一个**线程**去专门处理这个连接请求.

   1. 解决了fork代价够和进程通信复杂的问题.
   2. 线程间的互斥和共享又引入了复杂度,一步小心就出现了死锁的问题.
   3. 多线程之间会相互影响,并发几百的连接数,反而使用PPC方案.

5. Prethread方案

6. Reactor

   1. 进程复用,进程池.

   2. read操作改为非阻塞,然后进程不断的轮询多个连接,但是当连接数较多时候,轮询也会带来一定的压力.

   3. 自然的想法是当有数据的时候,进程才去处理,这就是I/O多路复用的技术.计算机里面的I/O多路复用技术复用是指多条连接复用同一个阻塞对象.

   4. 典型的实现方案

      1. 单进程/线程

         1. ![](..\picture\架构\Reactor_单进程线程.png)

         2. 实现步骤

            (1)  R e a c t o r对象通过s e l e c t监控连接事件，收到事件后通过d i s p a t c h进行分发。

            (2）如果是连接建立事件则由A c c e p t o r处理，A c c e p t o r通过a c c e p t接受连接，并创建一个Hand l e r来处理连接后续的各种事件。

            (3）如果不是连接建立事件，则R e a c t o r会调用连接对应的H a n d l e r（第2步中创建的H a n d l e r)来进行响应

            (4)  H a n d l e r完成r e a d－＞业务处理－＞s e n d的完整业务流程。

      2. 单Reactor多线程

         1. ![](..\picture\架构\Reactor_单Reactor多线程.png)
         2. Handler 只负责通知结果,不负责处理业务.

      3. 多Reactor多线程模式

         1. ![](..\picture\架构\多Reactor多线程.png)
         2. 多Reactor多进程实现的Nginx,采用多Reactor多线程实现有Memcache和Netty.

      4. Proactor

         1. 非阻塞同步网络模型,把用户I/O改成异步就能够进一步提升性能.

### 集群高性能

#### 负载均衡分类

1. DNS负载均衡,硬件负载均衡(一般没有那么大的业务量),软件负载均衡(LVS,Nginx)

#### 负载均衡算法

1. 常见的负载均衡算法
   1. 轮询: 优点简单,缺点是不关注服务的状态,只要服务在运行就会分配任务.
   2. 加权轮询
   3. 负载最低优先:可以根据连接数,请求数,CPU负载等策略
   4. 性能最优类,通过响应时间的维度来衡量外部的标准
   5. Hash类

## CAP

### 定义

1. 分布式计算机系统不可能同时满足三个特性:一致性(Consistence),可用性(Availability)和分区容错性(Partition Tolerance).
2. 
