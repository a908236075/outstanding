# 第一部分 概念和基础

## 基础架构

### 模块和组件的区别:

​	从逻辑的角度查分得来的单元是"模块",从物理角度拆分的系统得到的单元是"组件";划分模块的主要目的是职责分离,划分组件的主要目的是单元复用.

### 为什么要做架构设计

1. 架构设计是为了解决**复杂度**带来的问题.顺带解决了系统的高性能,高可用和可扩展.
2. 高性能
   1. 单机:手动输入命令-->批处理-->进程(CPU分成很多段,每个任务有独立的进程空间)--> 线程(为了让进程并行处理任务)
   2. 集群:

## 架构设计原则

### 合适原则

​	优秀的架构是业务量倒逼出来的,没有真实的场景永远是纸上谈兵.所以想提高,也点到真实的场景中去.

### 简单原则

​	Keep It Simple Stupid!

### 演化原则

​	演化优于一步到位.对于建筑来说,永恒是主题,对于软件来说,变化才是主题.

## 架构设计流程

### 识别系统复杂度

​	高性能,高可用和高扩展三方面,最多设计两方面的优化.

### 设计备选方案

1. 架构设计最常见的错误
   - 设计最优秀的方案.
   - 只做一个方案.正确的备选方案数量为3~5个.备选方案需要具有差异化.不能只局限于已经熟悉的技术.
   - 备选方案过于详细.

### 评估和选择备选方案

1. 最简派,最牛派,最熟派,领导派.
2. 常见错误:
   - 数量对比法 集群方案2个占优比拆分方案3个占优少,所以选择拆分方案.质量属性的重要性不等同.
   - 加权法:每个属性给一个权值,但是权值并不客观,放在不同的公司权值并不相同.
3. 正确的做法是:按优先级选择.例如创业公司可能成本最优先.
4. 避免方案重选
   1. 必须要深入理解选择方案的组件,例如ElastichSearch,熟悉它的细节.
   2. 降低方案复杂度,越复杂的方案越容易被细节推翻.
   3. 如果方案本身就很复杂,就让大家一起讨论.
5. 为什么任务分解就能提升性能呢
   1. 简单的系统更加容易做到高性能.
   2. 可以针对单个的任务进行扩展.
6. 高性能:系统无中断的执行其功能.
   1. 本质上通过"**冗余**"来解决高可用.
   2. 计算高可用和存储高可用.存储高可用的难点不在于如何备份数据,而在于如何减少或规避数据不一致对业务造成的影响.
7. 安全性在架构设计中很少体现,一般依靠运营商和云服务商.

## 存储高性能

### 读写分离

为了避免数据延时,可以将关键业务到主库读取,非关键业务到从库读取.

### 分库分表

1. 根据业务分库引发的问题:
   1. join操作不能直接查询
   2. 事务问题
   3. 成本问题

2. 怎样解决
   1. 单台数据库能够支撑10万用户量级的业务,对于创业团队,先可以不分库.

3. 分表
   1. 垂直分表:相较于水平更加的简单.
   2. 水平分表:单表行数超过5000万需要进行分表,仅仅最为参考,需要看业务数据具体的特性.
   3. 水平分表如何操作
      1. 范围路由:根据ID范围进行分表,分的太大,会使数据不均匀,分的太小会使维护变得困难.
      2. Hash路由:优先分布的比较均匀,缺点是扩充新的表很麻烦.
      3. 配合路由:新增一张中间表,将id映射关系保存在表中.缺点是每次查询都要多查询一次.

   4. 水平分表后的影响
      1. join操作:需要在业务代码或者数据库中间件中进行多次join查询,然后将结果合并.
      2. count操作
         1. 多报表查询然后count相加,如果串行很多表需要几秒钟才能获取到结果.
         2. 记录数表:新建一张表,专门记录数据总数,但会设计到数据添加异常导致不同步的问题.也增加了数据的读写压力.

      3. order by:能有通过业务代码进行汇总后排序.

4. 分库分表实现方法
   1. 程序代码封装:实现简单,每个变成夜宴都需要自己实现一次,无法通用.故障情况下如果主从切换发生,可能需要所有系统修改配置并重启.
   2. 中间件封装:主流的方式可以选择的是mysql-proxy,mysql-router,360的Atlas

### NoSQL

1. 相比于NoSql,**关系型数据库**有如下**缺点**:
   1. 无法存储数据结构.
   2. 表结构扩展很不方便,修改时间可能会长时间的锁表.
   3. 关系型数据库在大数据场景下I/O较高.
   4. 全文检索功能比较弱,即like.
2. NoSQL的类型
   1. K-V存储类型:解决关系型数据库无法存储数据结构的问题,Redis为代表.
   2. 文档数据库:~强Schema(表结构)约束的问题,MongoDB为代表.
   3. 列式数据库:~大数据场景下的I/O问题,以HBase为代表
   4. 全文搜索引擎:以ElastichSearch为代表.
3. K-V存储
   1. key都是String,Value包括:string,hash,list,set,sorted set,bitmap和hyperloglog.
   2. Redis的事务只能保证隔离性和一致性(I和C),无法保证原子性和持久性(A和D).
   3. Redis的ACID
      1. 原子性:不支持事务的回滚.随意不支持原子性.
      2. 一致性:保证事物开始之前和事务结束之后,数据库完整性没有被破坏.
      3. 隔离性:单线程,不存在多个事务的问题.
      4. 持久性:持久化方式:RDB和AOF.
   4. RDB与AOF
      1. RDB持久化只备份当前内存中的数据集，事务执行完毕时，其数据还在内存中，并未立即写入到磁盘，所以RDB持久化不能保证Redis事务的持久性。
      2. AOF持久化是先执行命令，执行成功后再将命令追加到日志文件中。即使AOF每次执行命令后立刻将日志文件刷盘，也可能丢失1条命令数据，因此AOF不能严格保证Redis事务的持久性。
4. 文档数据库
   1. 解决关系型数据库schema带来的问题.可以存储和读取任意类型的数据,存储最多的json.
   2. 但是不支持事务.无法实现join操作.
5. 列式数据库
   1. 传统关系型数据库被称为"行式数据库".在特性的业务场景下优势才能体现.
   2. 列式数据库,能够一次处理多列,例如查询超重人数,行式数据库即使只使用一列,也需要将所有行数据读取出来.
   3. 但是更新列的时候,由于列的空间不连续,则变成了随机的IO.
6. 全文搜索引擎.
   1. 倒排索引.

### 缓存

1. 需要用到缓存的场景
   1. 需要经过复杂运算后得出的数据,存储系统无能为力.
   2. 读多写少的数据.
2. Memcache,单台服务器简单的key-value查询能够达到5万以上的TPS.
3. 缓存穿透
   1. 存储数据不存在
      1. 当查询存储系统的数据没有找到,则直接设置一个默认值(可以是空值,也可以是一个具体的值)并存在缓存中.二次读取的时候获取的就是默认值,而不是访问存储系统.
   2. 缓存数据生成耗费大量时间或资源.
      1. 如果竞争对手用爬虫来遍历的时候,从第一页到最后一页都生成缓存数据.因为10页之后的数据可能没有缓存,导致大量的缓存需要生成.
      2. 解决办法是识别爬虫.
4. 缓存雪崩
   1. 当缓存失效后引起的性能急剧下降的情况.
   2. 解决方法:
      1. 更新锁:对缓存更新操作进行加锁保护.保证只有一个线程能够进行缓存更新.分布式系统要引入分布式锁如ZooKeeper.
      2. 后台更新:
         1. 后台线程更新而不是用业务线程进行更新缓存,但是当内存不够会踢掉一些缓存数据,为了避免被踢掉缓存读不到返回空值,有两种方法.
         2. 定时读取
            1. 后台线程除了定时更新缓存,还要频繁的读取缓存,间隔时间设置为1秒或者100毫秒.
            2. 消息队列通知
5. 缓存热点
   1. 虽然缓存系统本身的性能比较高,但对于热点数据,需要复制多份缓存.

## 计算高性能

### 单服务器高性能

1. 关键之一就是服务器采用的网络编程模型

2. PPC Process per Connection 的缩写
   1. 每次有新的连接就新建一个**进程**去专门处理这个连接的请求,传统UNIX网络服务所采用的模型.
   2. ![](..\picture\架构\PPC.png)
   3. 缺点:
      1. fork代价高,需要分配很多内核资源,需要将内存映像复制到子进程.
      2. 父子进行通信复杂.
      3. 大量的进程调度和切换对操作系统压力很大.

3. prefork:解决PPC模式fork代价大的问题.提前创建好进程.
   1. ![](..\picture\架构\prefork.png)
   2. 父子进程通信复杂,支持并发连接数有限的问题没有解决.

4. TPC:Thread per Connection 每次有新的连接就创建一个**线程**去专门处理这个连接请求.

   1. 解决了fork代价够和进程通信复杂的问题.
   2. 线程间的互斥和共享又引入了复杂度,一步小心就出现了死锁的问题.
   3. 多线程之间会相互影响,并发几百的连接数,反而使用PPC方案.

5. Prethread方案

6. Reactor

   1. 进程复用,进程池.

   2. read操作改为非阻塞,然后进程不断的轮询多个连接,但是当连接数较多时候,轮询也会带来一定的压力.

   3. 自然的想法是当有数据的时候,进程才去处理,这就是I/O多路复用的技术.计算机里面的I/O多路复用技术复用是指多条连接复用同一个阻塞对象.

   4. 典型的实现方案

      1. 单进程/线程

         1. ![](..\picture\架构\Reactor_单进程线程.png)

         2. 实现步骤

            (1)  R e a c t o r对象通过s e l e c t监控连接事件，收到事件后通过d i s p a t c h进行分发。

            (2）如果是连接建立事件则由A c c e p t o r处理，A c c e p t o r通过a c c e p t接受连接，并创建一个Hand l e r来处理连接后续的各种事件。

            (3）如果不是连接建立事件，则R e a c t o r会调用连接对应的H a n d l e r（第2步中创建的H a n d l e r)来进行响应

            (4)  H a n d l e r完成r e a d－＞业务处理－＞s e n d的完整业务流程。

      2. 单Reactor多线程

         1. ![](..\picture\架构\Reactor_单Reactor多线程.png)
         2. Handler 只负责通知结果,不负责处理业务.

      3. 多Reactor多线程模式

         1. ![](..\picture\架构\多Reactor多线程.png)
         2. 多Reactor多进程实现的Nginx,采用多Reactor多线程实现有Memcache和Netty.

      4. Proactor

         1. 非阻塞同步网络模型,把用户I/O改成异步就能够进一步提升性能.

### 集群高性能

#### 负载均衡分类

1. DNS负载均衡,硬件负载均衡(一般没有那么大的业务量),软件负载均衡(LVS,Nginx)

#### 负载均衡算法

1. 常见的负载均衡算法
   1. 轮询: 优点简单,缺点是不关注服务的状态,只要服务在运行就会分配任务.
   2. 加权轮询
   3. 负载最低优先:可以根据连接数,请求数,CPU负载等策略
   4. 性能最优类,通过响应时间的维度来衡量外部的标准
   5. Hash类

## CAP

### 定义

1. 分布式计算机系统不可能同时满足三个特性:一致性(Consistence),可用性(Availability)和分区容错性(Partition Tolerance).
2. 分区容错性是指:尽管出现消息对视或分区错误,但系统能够继续运行.
2. 因为网络不可能保证100%可靠,有可能出现故障,所以分区容错性是必须的选择.
2. AP:为了保证可用性,需要牺牲一致性.CP:为了保证一致性,而牺牲可用性.

### CAP细节

1. CAP 关注的是粒度是数据,而不是整个系统,一个系统可以同时存在CP和AP.

### ACID BASE

1. ACID   原子性 一致性  隔离性 持久性
2. BASE  
   1. **基本可用(Basically Available)**:  分布式系统出现故障时,允许损失部分可用性,即保证核心可用.
   2. **软状态(Soft State)** ::允许系统存在中间状态,而该中间状态不会影响系统整个可用性.该状态就是CAP说的数据不一致.
   3. **最终一致性(Eventual Consistency):**系统中所有数据副本经过一定时间后,最终能够达到一致的状态.
3. BASE 理论是对CAP中AP方案的一个补充.

## FMEA

### 概念

1. Failure and effects analysis 故障模型与影响分析

### FMEA方法

1. 给出初始的架构设计图.
2. 假设架构中某个部件发生故障.
3. 分析此故障对系统功能造成的影响.
4. 根据分析的结果,判断架构是否需药进行优化.

### FMEA分析表格

1. 功能点:从用户的角度为功能的.

## 存储高可用

### 方案本质

1. 本质是通过将数据复制到多个存储设备,通过数据冗余的方式实现高可用.其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题.

### 主备复制

1. 备机仅仅做数据的备份,当主机不能访问时候,需要人工将备机升级为主机.并处理由于延迟和中断导致的数据不一致的问题.

### 主从复制

1. 主机负责读写,从机只负责读操作.写少读多的业务使用此架构的比较多.例如论坛,BBS,新闻业务等.

#### 主备倒换与主从倒换	

### 主主复制

1. 有些数据天生不能用主主复制,例如用户注册的ID,商品的扣减.

### 分布式事务算法

1. 2PC
2. 3PC

### 分布式一致性算法

1. Paxos :被理论证明正确的算法,但是特别复杂,很难理解.
2. Raft:将一致性问题拆分为3个子问题:Leader选举,日志复制,安全保证.
3. ZAB:主要的区别是采用primary backup算法,而Paxos和Raft采用的是state machine replication算法
   1. primary backup: Leader节点执行操作,将执行结果复制给其它的节点.
   2. state machine replicationg:各个节点复制的是具体的操作,然后每个节点自己执行操作.

### 数据分区

1. 基于地理级别的故障来设计高可用架构,例如遇到地震是一个地区的电都停止了.

#### 复制规则

1. 集中式:有一个总的备份中心,所有的分区都将数据备份到备份中心.
2. 互备式:相互备份,设计比价复杂,扩展比较麻烦,但是成本低.
3. 独立式:每个服务器都有一个备份,但是放在地理位置不同的位置,设计简单但是成本高.

## 业务高可用

1. 跨城异地多活相比较同城和跨国更加的复杂.

### 实现异地多活的技巧

1. 优先实现核心业务的异地多活架构.
2. 核心数据最终一致性.
3. 采用多种手段保证同步.
   1. 消息队列方式.
   2. 二次读取的方式
   3. 存储系统同步的方式
   4. 回源读取方式,
   5. 重新生成数据方式.
4. 只保证绝大部分用户的异地多活.

### 异地多活设计步骤

1. 业务分级:根据访问量,核心业务和收入挑选出核心的业务.
2. 数据分类:数据量,唯一性,实时性,可丢失性,可恢复性.
3. 数据同步:存储系统同步(例如Mysql),消息队列同步(适合无事务性或无时序性要求的数据),重复生成.最终生成图片如下
   1. ![](..\picture\架构\异地多活设计步骤.png)

4. 异常处理
   1. 多通道同步:例如用消息队列和数据库同步同步用户账号信息.
   2. 同步和访问结合:同步和访问的采用不同的网络连接,例如接口访问走公网,同步走内网.
   3. 日志记录:
      1. 服务器上/数据库中保存日志,应对单台服务的故障.
      2. 本地独立系统保存日志,应对某些业务服务器和数据库同时宕机的情况.
      3. 日志异地保存:应对机房宕机的情况.
   4. 用户补偿

### 接口级的故障应对方案

#### 应对措施

1. 降级:可以是只提供部分功能,也可以完全停掉所有的功能.
2. 熔断:应对依赖的外部系统故障情况.由于依赖的接口拖慢整个请求,所以直接熔断返回错误,而放弃请求.例如1分钟30%请求响应时间超过1秒就熔断.
3. 限流:限流是从用户访问压力的角度来考虑应对故障.超出系统访问能力的请求将被丢弃.常用的方法是基于请求限流和基于资源限流.
4. 排队

## 可扩展模式

### 基本思想

1. 面向流程/服务/功能拆分

## 分层架构

1. C/S 架构 B/S 架构
2. MVC架构 MVP(Present)架构
3. 逻辑分层架构

## SOA架构

1. SOA:service oriented architecture 面向服务的架构.
2. 作用是将不同的企业服务整合成一个整体. ESB(企业服务总线)平台但是比较耗费性能,不适用于互联网.

## 微服务

### SOA VS 微服务

![](..\picture\架构\SOA与微服务的区别.png)

两种不同理念的架构模式.微服务的特点是small,automated,lightweight

### 微服务的陷阱

1. 服务划分过细,服务间关系复杂.
2. 服务数量太多,团队效率急剧下降.
3. 调用链太长,性能下降.定位问题困难.
4. 没有自动化支撑,无法快速交付.
5. 没有服务治理,微服务数量多了后台管理混乱(路由管理,故障隔离,注册发现).

### 微服务的最佳实践

1. 拆分方法
   - 基于业务逻辑
   - 基于可扩展
   - 基于可靠性
   - 基于性能
2. 基础设施
   1. ![](..\picture\架构\微服务基础设施.png)
   2. API网关,负责外部系统的访问操作,主要包括进入鉴权,权限控制,传输加密,请求路由,流量控制等功能.
   3. 服务路由一般不会设计成独立运行的系统,通常情况下和服务发现放在一起实现.常见的路由算法,随机路由,轮询路由,最小压力路由,最小连接数等.
   4. 服务容错:包括请求重试,流控,服务隔离,服务隔离分为:主动隔离,被动隔离和手动隔离.被动隔离由服务发现系统执行.
   5. 服务跟踪:
      1. 服务监控可以做到微服务节点级的架空和信息收集,但是想要跟踪某个请求在微服务中的完整路径,服务监控是难以实现的.
      2. 通过标注点:在中间件或系统中,给请求定义一个全局标识,通过这个ID将整个请求串联起来.

## 微内核架构

### 基本概念

1. 定义:微内核架构也被称为插件化架构,是一种面向功能进行拆分的可扩展架构.
2. 由核心系统和插件模块组成:核心系统负责和具体业务无关的通用功能,例如模块加载,模块之间的通信等.插件负责业务.

### 设计关键点

1. 插件管理,插件的连接,插件通信.

## 消息队列设计实战

### 设计流程

1. 通过高性能,高可用和高扩展逐一排除.高性能通过TPS和QPS每秒事务数和每秒查询数进行衡量,一般取平均值的3倍计算性能,平均值的4倍考虑业务的增长,1000万条消息,和1亿此的读取.最终TPS 345  QPS是3450.

## 互联网架构演进

### 技术演进的动力

1. 对于产品类创新推动业务的发展.而服务类正好相反.因为服务类更讲规模和生态.
2. 当规模成为业务的决定因素后,服务模式的创新就成为了业务发展的核心驱动力.而产品是为了完成服务的载体,例如淘宝形成规模后,需要提供支付,物流等服务.

### 业务复杂性

1. 初创期
2. 发展期:
   1. 堆功能:
   2. 优化期:
      1. 优化派:通过换数据库,增加服务器,增加缓存,优化业务逻辑等进行优化,一开始是有效的
      2. 架构派:将大系统拆分成多个相互配合的小系统.一般在架构期才会采用.
   3. 架构期:
      1. 伴随着各种 拆 拆 拆: 拆功能,拆数据库,拆服务器.
   4. 竞争期:
      1. 因为相互竞争模仿,所以业务更加的庞大,导致原来系统数量越来越多,到了临界点就会发生质变.
         1. 重复造轮子.
         2. 系统交互一团乱麻.
      2. 解决办法:
         1. 平台化:解决重复造轮子的问题.例如存储平台化,数据库平台化,缓存平台化.
         2. 服务化:目的是解决交互,引入Kafka,ActiveMQ问题.
   5. 成熟期:平台优化成为了首要的任务.

## 互联网架构模板

1. 









