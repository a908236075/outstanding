Java 线程池中 submit() 和 execute()方法有什么区别？

Java中的线程池是一个非常重要的多线程编程工具，它可以通过预先创建一组线程并维护着队列来管理并发很高的任务。在使用线程池时，开发人员可以使用两个主要的方法submit()和execute()提交任务。虽然它们看起来很相似，但它们之间有一些关键的区别，下面将会详细介绍这些区别。

1、提交方式  首先，submit()方法是定义在ExecutorService接口中的，它允许开发人员提交一个Callable或Runnable对象给线程池来执行，返回一个Future对象，可以用于检索结果或取消任务。而execute()方法是定义在Executor接口中的，只接收Runnable对象，并且没有返回类型。简单来说，submit()方法更加灵活，可以处理带返回值的任务，而execute()只能处理不带返回值的任务。

2、异常处理  第二个关键区别是异常处理。当任务本身抛出一个未检查异常时，开发人员通常需要了解此异常的类型以及该如何处理它。当使用submit()方法时，该异常会被包装在一个ExecutionException中并重新抛出。因此，在使用该方法时，开发人员必须捕获ExecutionException或声明它可能抛出。而在使用execute()方法时，异常将不会被重新抛出。这使得异常处理变得更加困难，因为开发人员必须自己处理异常。

3、队列策略  线程池通常会使用队列来保存已提交但未处理的任务。线程池如何使用这个队列，被称为队列策略。通过submit()方法提交的任务，会被添加到阻塞队列中，并保留之前提交的任务执行顺序。而对于execute()方法提交的任务，将会被添加到队列的尾部。这意味着队列中的第一个任务是最早的任务并且先被执行。

4、任务的处理过程与方式  submit()和execute()两种方式在任务的处理方式上存在一定的差异。submit()方法在处理任务时，将任务交由一个线程池中的工作线程去处理，而另一个线程（可能是主线程）可以继续做其他事情。负责处理submit()方法提交的任务的线程，当任务结束后会自动返回给线程池并等待下一个任务，从而避免了重复创建和销毁线程的开销。而execute()方法则不同，它的任务直接在调用execute()方法的调用线程（通常是主线程）中运行，如果当前没有可用线程，则会立即创建新的线程来处理该任务，并在完成任务后销毁线程。

5、消息传递方式  在submit()和execute()方法中，消息传递方式也存在差异。submit()方法中提交的任务可以通过Future对象获取执行结果，开发人员可以使用该对象等待线程池中对应的任务完成，并获取其返回值；而execute()方法则没有提供返回值或者其他机制来获取任务的执行情况，因此即便一个任务执行失败了，开发人员也无法了解到在哪里以及什么地方出现了问题。

综上所述，submit()和execute()的方法虽然名字类似并且都可以用来提交任务到线程池，但是它们之间还是存在很大的区别。对于需要处理返回值、异常处理、顺序性比较要求高的任务，建议使用submit()方法，而如果只是需要快速完成一个不需要关注返回结果的任务，可以考虑使用execute()方法。

当然，在实际编程过程中，并不是绝对只使用其中一种方式，实际选择要根据具体的场景和需求进行权衡。