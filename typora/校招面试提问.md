# 问题

## 网络

1. 网络七层.

2. UDP和TCP协议的区别.

   1. TCP

      - 优点：可靠 稳定

        TCP的可靠体现在TCP在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认. 窗口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源.

      - 缺点：慢，效率低，占用系统资源高，易被攻击

   2. UDP

      - 优点：快，比TCP稍安全

        UDP没有TCP拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有TCP的这些机制，被攻击利用的机会就少一些，但是也无法避免被攻击。

      - 缺点：不可靠，不稳定

        因为没有TCP的这些机制，UDP在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失。

3. TCP的三次握手和四次挥手 ,少一次挥手可不可以.

## 底层原理

1. HashMap和concurrenthashmap区别及两者的优缺点
   1. HashMap:
      - 底层是数组+链表+红黑树.数组的默认长度是16.负载因子是0.75.
      - 对key进行hash出一个index,将值保存在此位置.为了避免hash冲突,JDK 1.8 引入了红黑树，**当链表的长度大于 8 的时候就会转换为红黑树，不过，在转换之前，会先去查看 table 数组的长度是否大于 64，如果数组的长度小于 64，那么 HashMap 会优先选择对数组进行扩容** resize**，而不是把链表转换成红黑树。**当桶中的元素数量小于等于6的时候又会转为链表.
      - JDK1.8采用的事尾插法:保持表元素原本的顺序,避免链表成环的问题.但是JDK1.8的HashMap仍然不是线程安全的,put未加锁,导致数据覆盖.

   2. concurrentHashMap:1.7使用的是分段锁,相比于直接加锁,只对一段数据加锁避免了锁冲突.1.8使用了CAS和Synchronize进行了优化.
      - put方法
        1. 做插入操作时，首先进入乐观锁，
        2.  然后，在乐观锁中判断容器是否初始化，
        3.  如果没初始化则初始化容器，
        4.  如果已经初始化，则**判断该`hash`位置的节点是否为空，如果为空，则通过CAS操作进行插入**。
        5.  如果该节点不为空，再判断容器是否在扩容中，如果在扩容，则帮助其扩容。
        6.  如果没有扩容，则进行最后一步，**先加锁，然后找到`hash`值相同的那个节点(hash冲突)，**
        7.  **循环判断这个节点上的链表，决定做覆盖操作还是插入操作**。
        8.  循环结束，插入完毕。

      - 如果没有相同的key,则使用CAS进行插入.

      - get方法是通过volatile关键字保证了可见性.
   
      - 锁 : 锁是锁的链表的head的节点,不影响其他元素的读写,锁粒度更细,效率更高,扩容时,阻塞所有的读写操作(因为扩容的时候使用的是Synchronized锁,锁全表),并发扩容.
   
2. collections.sort()排序原理.
   1. 快速排序和优化的归并排序.快速排序不稳定.归并排序比较的次数比较少.移动的次数比较多.
   2. 两种排序的时间复杂度为nlog2N,快速排序的空间复杂度nLog2N,归并为O(n);

## 虚拟机

1. 内存模型
2. 垃圾回收算法.
3. 怎么判断对象需要回收.
4. 垃圾处理器.
5. 锁升级
6. volatile和synchronized的区别.
7. 类加载的过程. 
   1. 加载 验证  准备 解析  初始化
8. 双亲委派机制

## 多线程

1. 多线程的实现方式.
2. 线程池的主要参数.
3. 多线程为什么会发生死锁,如何避免死锁.

## Mysql数据库

1. 搜索引擎 
2. 聚簇索引和非聚簇索引.建立索引的语句.索引最左匹配原则.
3. BTree和B+Tree不同:
    （1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
    （2）为所有叶子节点增加了一个链指针
4. 事务的特性:原子性,一致性,隔离性,永久性.
5. 数据库的隔离级别:mysql 可重复读 Oracle 默认的 读已提交.
6. 全局锁,表锁和行锁.
7. sql case when  平均成绩>60分的学号.

## Redis

1. 数据结构类型.String,list,hash,set,zset.
2. 持久化机制.第一种是快照RDB，第二种是 AOF 日志.
3. 数据一致性问题.
4. Redis的事物仅仅满足了隔离性,而没有满足原子性.
5. 过期策略.定时扫描策略使用的贪心策略.
6. 布隆过滤器.
7. 集群模式 复制模式 哨兵模式.

## SSM框架

1. IOC,AOP
2. Bea的生命周期 实例化 属性赋值 初始化 销毁
3. Bean注入的方式.构造方法注入和Set方法的注入.
4. 循环依赖问题.AOP的使用场景 .
5. Application和BeanFactory的区别 Application启动的时候完成所有的初始化,需要更多的系统资源.
6. Spring提供了两种方式来生成代理对象:  JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。
7. 事务的传播机制

## Kafka

1. 使用哪种插件操作kafka ,kafka常用的shell脚本,topic consumer producer group .
2. 主题,分区.分区的主从副本的概念.高水位的概念.
3. 位移提交的方式,优缺点是什么.
4. kafka支持减少分区数吗?
5. 消费者的推拉两种模式, 各个优缺点.
6. 消息丢失和重复消费的问题.

## 架构

1. 

## 设计模式

1. 工厂设计模式
2. 代理模式.

## 开放性问题

1. 系统慢了,怎么排查.

----

