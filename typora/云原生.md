# 云原生

## 云平台分类

## 服务架构变革

1. 分布式:拆分出多个功能模块,每个功能模块分布在不同的服务器上,完成整个系统的功能.
2. 集群:拆分出来的单个服务能力不够用了,需要进行复制成多个服务,多个服务一起提供服务.集群需要部署在不同的服务器上.
3. 微服务:分布式演进而来,以业务为单元直接进行了分库,分离.通过RPC进行调用.

## 云原生的12概念

## 其它概念

1. 蓝绿部署
   1. 蓝色稳定运行,让新的增加服务部署到绿环境,实验稳定转换成蓝环境.

## Docker 

### 隔离原理

1. 资源隔离与资源的限制.

## 部署应用

1. ~~~sh
   ##初始化网络
   kubeadm init \
   --apiserver-advertise-address=10.170.11.8 \
   --image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \
   --kubernetes-version v1.21.0 \
   --service-cidr=10.96.0.0/16 \
   --pod-network-cidr=192.168.0.0/16
   
   --pod-network-cidr=192.168.0.0/16：pod 的ip范围
   ## 部署
   kubectl create deployment my-nginx --image=nginx
   ~~~

2. 

## K8S 故障排除

1. **kubectl get** - 显示资源列表

   - ```sh
     # kubectl get 资源类型
     
     #获取类型为Deployment的资源列表
     kubectl get deployments
     
     #获取类型为Pod的资源列表
     kubectl get pods
     
     #获取类型为Node的资源列表
     kubectl get nodes
     ```

   - ```sh
     # 查看所有名称空间的 Deployment
     kubectl get deployments -A
     kubectl get deployments --all-namespaces
     # 查看 kube-system 名称空间的 Deployment
     kubectl get deployments -n kube-system
     ```

   - ```sh
     #####并不是所有的对象都在名称空间中
     
     # 在名称空间里
     kubectl api-resources --namespaced=true
     
     # 不在名称空间里
     kubectl api-resources --namespaced=false
     ```

2. **kubectl describe** - 显示有关资源的详细信息

   - ```sh
     # kubectl describe 资源类型 资源名称
     
     #查看名称为nginx-XXXXXX的Pod的信息
     kubectl describe pod nginx-XXXXXX	
     
     #查看名称为nginx的Deployment的信息
     kubectl describe deployment my-nginx	
     ```

     

3. **kubectl logs** - 查看pod中的容器的打印日志（和命令docker logs 类似）

   - ```sh
     # kubectl logs Pod名称
     
     #查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志
     #本案例中的 nginx-pod 没有输出日志，所以您看到的结果是空的
     kubectl logs -f nginx-pod-XXXXXXX
     ```

4. **kubectl exec** - 在pod中的容器环境内执行命令(和命令docker exec 类似)

   - ```sh
     # kubectl exec Pod名称 操作命令
     
     # 在名称为nginx-pod-xxxxxx的Pod中运行bash
     kubectl exec -it nginx-pod-xxxxxx /bin/bash
     
     ### 注意：新版1.21.0 提示这个命令会过期
     ```

5. **kubectl run**

   - ~~~sh
     ## kubectl run --help  也可以独立跑一个Pod
     kubectl run nginx --image=nginx
     ~~~

6. **kubectl expose**

   - ~~~sh
      kubectl expose deployment tomcat6 --port=8912 --target-port=8080 --type=NodePort
      
      ## --port：集群内访问service的端口 8912
      ## --target-port： pod容器的端口 8080
      ## --nodePort： 每个机器开发的端口 30403
      
      
      ## 进行验证
      kubectl get svc 
      curl ip:port 
      
      ## kubectl exec 进去pod修改，并测试负载均衡
     ~~~

7. 扩缩容

   - ~~~sh
     ## 扩展
     kubectl scale --replicas=3  deployment tomcat6
     
     #持续观测效果
     watch kubectl get pods -o wide
     ~~~

8. 升级与回滚

   - ~~~sh
     #应用升级: tomcat:alpine、tomcat:jre8-alpine
     kubectl set image deployment.apps/tomcat6 tomcat=tomcat:jre8-alpine #可以携带--record参数，记录变更
     
     
     ##回滚升级
     ### 查看历史记录
     kubectl rollout history deployment.apps/tomcat6
     kubectl rollout history deploy tomcat6
     
     ### 回滚到指定版本
     kubectl rollout undo deployment.apps/tomcat6 --to-revision=1
     kubectl rollout undo deploy tomcat6 --to-revision=1
     ~~~

9. 部署应用

   - ~~~sh
     kubectl apply -f xxx.yaml
     ~~~


## K8S 对象描述文件

1. ~~~sh
   kubectl run my-nginx666 --image=nginx #启动一个Pod
   kubectl get pod my-nginx666 -oyaml 集群中挑一个同类资源，获取出他的yaml。
   kubectl run my-tomcat --image=tomcat --dry-run -oyaml 干跑一遍
   ~~~

2. ~~~yaml
   kind: Pod      #资源类型 kubectl api-resources:可以获取到所有资源
   apiVersion: v1   #同一个资源有可能有多个版本。看 kubectl api-resources提示的。
   metadata:      #每一个资源定义一些元数据信息
   labels:
    run: my-tomcat
   name: my-tomcat
   spec:  #资源的规格（镜像名、镜像的环境变量信息等等）
   containers:
   - image: tomcat
    name: my-tomcat
    resources: {}
   dnsPolicy: ClusterFirst
   restartPolicy: Always
   ~~~

## 命名空间

1. ~~~sh
   #1、命令式
   kubectl run nginx --image nginx
   kubectl create deployment nginx --image nginx
   kubectl create deployment nginx --image nginx --dry-run=client -oyaml
   apply -f ： 没有就创建，有就修改
   #2、指令性
   - 使用指令性的对象配置（imperative object configuration）时，需要向 kubectl 命令指定具体
   的操作（create,replace,apply,delete等），可选参数以及至少一个配置文件的名字。配置文件中必须
   包括一个完整的对象的定义，可以是 yaml 格式，也可以是 json 格式。
   #获取yaml
   kubectl create ns hello --dry-run=client -oyaml
   #创建对象
   kubectl create -f nginx.yaml
   #删除对象
   kubectl delete -f nginx.yaml -f redis.yaml
   #替换对象
   kubectl replace -f nginx.yaml
   #3、声明式
   #处理 configs 目录中所有配置文件中的Kubernetes对象，根据情况创建对象、或更新Kubernetes中已
   经存在的对象。可以先执行 diff 指令查看具体的变更，然后执行 apply 指令执行变更；
   kubectl diff -f configs/
   kubectl apply -f configs/
   #递归处理目录中的内容：
   kubectl diff -R -f configs/
   kubectl apply -R -f configs/
   #移除
   kubectl delete -f configs/
   ~~~
   

## 工作负载 deployment

1. ~~~sh
   ################更新#################################
   #kubectl set image deployment资源名 容器名=镜像名
   kubectl set image deployment.apps/nginx-deployment php-redis=tomcat:8 --record
   #或者直接修改定义也行
   kubectl edit deployment.v1.apps/nginx-deployment
   #查看状态
   kubectl rollout status deployment.v1.apps/nginx-deployment
   ################查看历史并回滚####################################
   #查看更新历史-看看我们设置的历史总记录数是否生效了
   kubectl rollout history deployment.v1.apps/nginx-deployment
   #回滚
   kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2
   ###############累计更新##############
   #暂停记录版本
   kubectl rollout pause deployment.v1.apps/nginx-deployment
   #多次更新操作。
   ##比如更新了资源限制
   kubectl set resources deployment.v1.apps/nginx-deployment -c=nginx --
   limits=cpu=200m,memory=512Mi
   ##比如更新了镜像版本
   kubectl set image deployment.apps/nginx-deployment php-redis=tomcat:8
   ##在继续操作多次
   ##看看历史版本有没有记录变化
   kubectl rollout history deployment.v1.apps/nginx-deployment
   #让多次累计生效
   kubectl rollout resume deployment.v1.apps/nginx-deployment
   ~~~

1. 

